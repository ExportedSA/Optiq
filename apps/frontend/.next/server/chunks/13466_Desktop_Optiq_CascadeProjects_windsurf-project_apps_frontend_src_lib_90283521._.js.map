{"version":3,"sources":["../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/integrations/encryption.ts","../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/jobs/run-daily-sync.ts","../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/integrations/token-refresh.ts","../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/integrations/meta-ads-client.ts","../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/integrations/google-ads-client.ts"],"sourcesContent":["/**\r\n * Token Encryption Utilities\r\n * \r\n * Encrypts and decrypts OAuth tokens for secure storage\r\n */\r\n\r\nimport \"server-only\";\r\nimport crypto from \"crypto\";\r\n\r\nconst ALGORITHM = \"aes-256-gcm\";\r\nconst IV_LENGTH = 16;\r\nconst AUTH_TAG_LENGTH = 16;\r\nconst SALT_LENGTH = 32;\r\n\r\n/**\r\n * Get encryption key from environment\r\n */\r\nfunction getEncryptionKey(): Buffer {\r\n  const key = process.env.TOKEN_ENCRYPTION_KEY;\r\n  if (!key) {\r\n    throw new Error(\"TOKEN_ENCRYPTION_KEY environment variable is required\");\r\n  }\r\n  \r\n  // Key should be 32 bytes (64 hex chars) for AES-256\r\n  if (key.length !== 64) {\r\n    throw new Error(\"TOKEN_ENCRYPTION_KEY must be 64 hex characters (32 bytes)\");\r\n  }\r\n  \r\n  return Buffer.from(key, \"hex\");\r\n}\r\n\r\n/**\r\n * Encrypt a token\r\n */\r\nexport function encryptToken(plaintext: string): string {\r\n  if (!plaintext) {\r\n    throw new Error(\"Cannot encrypt empty token\");\r\n  }\r\n\r\n  const key = getEncryptionKey();\r\n  \r\n  // Generate random IV\r\n  const iv = crypto.randomBytes(IV_LENGTH);\r\n  \r\n  // Create cipher\r\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\r\n  \r\n  // Encrypt\r\n  const encrypted = Buffer.concat([\r\n    cipher.update(plaintext, \"utf8\"),\r\n    cipher.final(),\r\n  ]);\r\n  \r\n  // Get auth tag\r\n  const authTag = cipher.getAuthTag();\r\n  \r\n  // Combine: iv + authTag + encrypted\r\n  const combined = Buffer.concat([iv, authTag, encrypted]);\r\n  \r\n  // Return as base64\r\n  return combined.toString(\"base64\");\r\n}\r\n\r\n/**\r\n * Decrypt a token\r\n */\r\nexport function decryptToken(ciphertext: string): string {\r\n  if (!ciphertext) {\r\n    throw new Error(\"Cannot decrypt empty ciphertext\");\r\n  }\r\n\r\n  const key = getEncryptionKey();\r\n  \r\n  // Decode from base64\r\n  const combined = Buffer.from(ciphertext, \"base64\");\r\n  \r\n  // Extract components\r\n  const iv = combined.subarray(0, IV_LENGTH);\r\n  const authTag = combined.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);\r\n  const encrypted = combined.subarray(IV_LENGTH + AUTH_TAG_LENGTH);\r\n  \r\n  // Create decipher\r\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\r\n  decipher.setAuthTag(authTag);\r\n  \r\n  // Decrypt\r\n  const decrypted = Buffer.concat([\r\n    decipher.update(encrypted),\r\n    decipher.final(),\r\n  ]);\r\n  \r\n  return decrypted.toString(\"utf8\");\r\n}\r\n\r\n/**\r\n * Generate a new encryption key (for setup)\r\n */\r\nexport function generateEncryptionKey(): string {\r\n  return crypto.randomBytes(32).toString(\"hex\");\r\n}\r\n\r\n/**\r\n * Verify encryption/decryption works\r\n */\r\nexport function verifyEncryption(): boolean {\r\n  try {\r\n    const testData = \"test-token-\" + Date.now();\r\n    const encrypted = encryptToken(testData);\r\n    const decrypted = decryptToken(encrypted);\r\n    return testData === decrypted;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n","/**\r\n * Daily Sync Job\r\n * \r\n * Syncs cost data from all connected ad platforms\r\n * - Iterates IntegrationConnections\r\n * - Fetches daily spend/clicks/impressions by grain\r\n * - Writes CostFact with idempotent upsert\r\n * - Handles rate limits and retries\r\n * - Records IngestionJob rows\r\n */\r\n\r\nimport \"server-only\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { appLogger } from \"@/lib/observability\";\r\nimport { getValidAccessToken } from \"@/lib/integrations/token-refresh\";\r\nimport { fetchMetaCostData, withRetry as metaRetry } from \"@/lib/integrations/meta-ads-client\";\r\nimport { fetchGoogleAdsCostData, withRetry as googleRetry } from \"@/lib/integrations/google-ads-client\";\r\nimport type { PlatformCode, CostGrain, IngestionJobStatus } from \"@prisma/client\";\r\n\r\nexport interface DailySyncOptions {\r\n  /** Specific organization to sync */\r\n  organizationId?: string;\r\n  /** Start date for sync */\r\n  fromDate?: Date;\r\n  /** End date for sync */\r\n  toDate?: Date;\r\n  /** Specific platform to sync */\r\n  platformCode?: PlatformCode;\r\n  /** Cost grain levels to sync */\r\n  grains?: CostGrain[];\r\n}\r\n\r\nexport interface DailySyncResult {\r\n  startedAt: Date;\r\n  completedAt: Date;\r\n  organizationsProcessed: number;\r\n  connectionsProcessed: number;\r\n  costFactsCreated: number;\r\n  costFactsUpdated: number;\r\n  errors: number;\r\n  jobIds: string[];\r\n}\r\n\r\nconst DEFAULT_GRAINS: CostGrain[] = [\"CAMPAIGN\", \"ADSET\", \"AD\"];\r\n\r\n/**\r\n * Run daily sync for all or specific organizations\r\n */\r\nexport async function runDailySync(options?: DailySyncOptions): Promise<DailySyncResult> {\r\n  const logger = appLogger.child({ job: \"daily-sync\" });\r\n  const startedAt = new Date();\r\n\r\n  // Default date range: yesterday\r\n  const yesterday = new Date();\r\n  yesterday.setDate(yesterday.getDate() - 1);\r\n  yesterday.setHours(0, 0, 0, 0);\r\n\r\n  const fromDate = options?.fromDate || yesterday;\r\n  const toDate = options?.toDate || yesterday;\r\n  const grains = options?.grains || DEFAULT_GRAINS;\r\n\r\n  logger.info(\"Starting daily sync\", {\r\n    organizationId: options?.organizationId,\r\n    fromDate: fromDate.toISOString(),\r\n    toDate: toDate.toISOString(),\r\n    platformCode: options?.platformCode,\r\n    grains,\r\n  });\r\n\r\n  let organizationsProcessed = 0;\r\n  let connectionsProcessed = 0;\r\n  let costFactsCreated = 0;\r\n  let costFactsUpdated = 0;\r\n  let errors = 0;\r\n  const jobIds: string[] = [];\r\n\r\n  try {\r\n    // Get organizations to process\r\n    const organizations = await prisma.organization.findMany({\r\n      where: options?.organizationId ? { id: options.organizationId } : {},\r\n      select: { id: true, name: true },\r\n    });\r\n\r\n    for (const org of organizations) {\r\n      logger.info(\"Processing organization\", { organizationId: org.id, name: org.name });\r\n\r\n      // Get active connections for this org\r\n      const connections = await prisma.integrationConnection.findMany({\r\n        where: {\r\n          organizationId: org.id,\r\n          status: \"CONNECTED\",\r\n          ...(options?.platformCode ? { platformCode: options.platformCode } : {}),\r\n        },\r\n        include: {\r\n          organization: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n      });\r\n\r\n      logger.info(\"Found connections\", {\r\n        organizationId: org.id,\r\n        count: connections.length,\r\n      });\r\n\r\n      for (const connection of connections) {\r\n        try {\r\n          // Create ingestion job record\r\n          const job = await createIngestionJob(\r\n            connection.organizationId,\r\n            connection.platformCode,\r\n            fromDate,\r\n            toDate,\r\n            grains\r\n          );\r\n          jobIds.push(job.id);\r\n\r\n          logger.info(\"Processing connection\", {\r\n            connectionId: connection.id,\r\n            platform: connection.platformCode,\r\n            accountId: connection.externalAccountId,\r\n            jobId: job.id,\r\n          });\r\n\r\n          // Update job status to running\r\n          await updateIngestionJob(job.id, \"RUNNING\");\r\n\r\n          // Sync data for this connection\r\n          const result = await syncConnection(\r\n            connection.id,\r\n            connection.platformCode,\r\n            connection.externalAccountId,\r\n            fromDate,\r\n            toDate,\r\n            grains\r\n          );\r\n\r\n          costFactsCreated += result.created;\r\n          costFactsUpdated += result.updated;\r\n          connectionsProcessed++;\r\n\r\n          // Update job status to completed\r\n          await updateIngestionJob(job.id, \"COMPLETED\", {\r\n            costFactsCreated: result.created,\r\n            costFactsUpdated: result.updated,\r\n          });\r\n\r\n          logger.info(\"Connection synced successfully\", {\r\n            connectionId: connection.id,\r\n            created: result.created,\r\n            updated: result.updated,\r\n          });\r\n        } catch (error) {\r\n          errors++;\r\n          logger.error(\"Failed to sync connection\", {\r\n            connectionId: connection.id,\r\n            platform: connection.platformCode,\r\n            error: error as Error,\r\n          });\r\n\r\n          // Update job status to failed\r\n          const job = jobIds[jobIds.length - 1];\r\n          if (job) {\r\n            await updateIngestionJob(job, \"FAILED\", undefined, (error as Error).message);\r\n          }\r\n        }\r\n      }\r\n\r\n      organizationsProcessed++;\r\n    }\r\n  } catch (error) {\r\n    logger.error(\"Daily sync failed\", error as Error);\r\n    throw error;\r\n  }\r\n\r\n  const completedAt = new Date();\r\n\r\n  logger.info(\"Daily sync completed\", {\r\n    organizationsProcessed,\r\n    connectionsProcessed,\r\n    costFactsCreated,\r\n    costFactsUpdated,\r\n    errors,\r\n    durationMs: completedAt.getTime() - startedAt.getTime(),\r\n  });\r\n\r\n  return {\r\n    startedAt,\r\n    completedAt,\r\n    organizationsProcessed,\r\n    connectionsProcessed,\r\n    costFactsCreated,\r\n    costFactsUpdated,\r\n    errors,\r\n    jobIds,\r\n  };\r\n}\r\n\r\n/**\r\n * Sync a single connection\r\n */\r\nasync function syncConnection(\r\n  connectionId: string,\r\n  platformCode: PlatformCode,\r\n  externalAccountId: string,\r\n  fromDate: Date,\r\n  toDate: Date,\r\n  grains: CostGrain[]\r\n): Promise<{ created: number; updated: number }> {\r\n  const logger = appLogger.child({ connectionId, platform: platformCode });\r\n\r\n  let created = 0;\r\n  let updated = 0;\r\n\r\n  // Get valid access token (auto-refreshes if needed)\r\n  const accessToken = await getValidAccessToken(connectionId);\r\n\r\n  // Get connection details\r\n  const connection = await prisma.integrationConnection.findUnique({\r\n    where: { id: connectionId },\r\n  });\r\n\r\n  if (!connection) {\r\n    throw new Error(\"Connection not found\");\r\n  }\r\n\r\n  // Get platform and ad account\r\n  const platform = await prisma.platform.findFirst({\r\n    where: { code: platformCode },\r\n  });\r\n\r\n  if (!platform) {\r\n    throw new Error(`Platform not found: ${platformCode}`);\r\n  }\r\n\r\n  const adAccount = await prisma.adAccount.findFirst({\r\n    where: {\r\n      organizationId: connection.organizationId,\r\n      platformId: platform.id,\r\n      externalId: externalAccountId,\r\n    },\r\n  });\r\n\r\n  if (!adAccount) {\r\n    throw new Error(`Ad account not found: ${externalAccountId}`);\r\n  }\r\n\r\n  // Fetch and upsert data for each grain\r\n  for (const grain of grains) {\r\n    logger.debug(\"Syncing grain\", { grain });\r\n\r\n    let costData: any[] = [];\r\n\r\n    // Fetch data based on platform\r\n    if (platformCode === \"META_ADS\") {\r\n      costData = await metaRetry(() =>\r\n        fetchMetaCostData(accessToken, externalAccountId, fromDate, toDate, grain)\r\n      );\r\n    } else if (platformCode === \"GOOGLE_ADS\") {\r\n      const developerToken = process.env.GOOGLE_ADS_DEVELOPER_TOKEN;\r\n      if (!developerToken) {\r\n        throw new Error(\"GOOGLE_ADS_DEVELOPER_TOKEN not configured\");\r\n      }\r\n      costData = await googleRetry(() =>\r\n        fetchGoogleAdsCostData(\r\n          accessToken,\r\n          developerToken,\r\n          externalAccountId,\r\n          fromDate,\r\n          toDate,\r\n          grain\r\n        )\r\n      );\r\n    } else {\r\n      logger.warn(\"Unsupported platform\", { platformCode });\r\n      continue;\r\n    }\r\n\r\n    // Upsert CostFacts\r\n    for (const data of costData) {\r\n      const result = await upsertCostFact(\r\n        connection.organizationId,\r\n        platform.id,\r\n        adAccount.id,\r\n        grain,\r\n        data\r\n      );\r\n\r\n      if (result.created) created++;\r\n      else updated++;\r\n    }\r\n\r\n    logger.info(\"Grain synced\", { grain, records: costData.length });\r\n  }\r\n\r\n  return { created, updated };\r\n}\r\n\r\n/**\r\n * Upsert a CostFact record (idempotent)\r\n */\r\nasync function upsertCostFact(\r\n  organizationId: string,\r\n  platformId: string,\r\n  adAccountId: string,\r\n  grain: CostGrain,\r\n  data: any\r\n): Promise<{ created: boolean }> {\r\n  const date = new Date(data.date);\r\n  date.setHours(0, 0, 0, 0);\r\n\r\n  // Check if exists\r\n  const existing = await prisma.costFact.findFirst({\r\n    where: {\r\n      organizationId,\r\n      platformId,\r\n      adAccountId,\r\n      date,\r\n      grain,\r\n      entityExternalId: data.entityExternalId,\r\n      publisherPlatform: null, // For now, we don't track publisher platform\r\n    },\r\n  });\r\n\r\n  const costFactData = {\r\n    organizationId,\r\n    platformId,\r\n    adAccountId,\r\n    date,\r\n    grain,\r\n    entityExternalId: data.entityExternalId,\r\n    entityName: data.entityName,\r\n    campaignExternalId: data.campaignExternalId,\r\n    campaignName: data.campaignName,\r\n    adsetExternalId: data.adsetExternalId || data.adGroupExternalId,\r\n    adsetName: data.adsetName || data.adGroupName,\r\n    adExternalId: data.adExternalId,\r\n    adName: data.adName,\r\n    publisherPlatform: null,\r\n    impressions: BigInt(data.impressions),\r\n    clicks: BigInt(data.clicks),\r\n    spendMicros: BigInt(data.spendMicros),\r\n    conversions: BigInt(0), // Will be filled by attribution\r\n    revenueMicros: BigInt(0), // Will be filled by attribution\r\n  };\r\n\r\n  if (existing) {\r\n    // Update existing\r\n    await prisma.costFact.update({\r\n      where: { id: existing.id },\r\n      data: {\r\n        ...costFactData,\r\n        updatedAt: new Date(),\r\n      },\r\n    });\r\n    return { created: false };\r\n  } else {\r\n    // Create new\r\n    await prisma.costFact.create({\r\n      data: costFactData,\r\n    });\r\n    return { created: true };\r\n  }\r\n}\r\n\r\n/**\r\n * Create an ingestion job record\r\n */\r\nasync function createIngestionJob(\r\n  organizationId: string,\r\n  platformCode: PlatformCode,\r\n  fromDate: Date,\r\n  toDate: Date,\r\n  grains: CostGrain[]\r\n): Promise<{ id: string }> {\r\n  const idempotencyKey = `daily-sync-${organizationId}-${platformCode}-${fromDate.toISOString().split(\"T\")[0]}-${toDate.toISOString().split(\"T\")[0]}`;\r\n\r\n  const job = await prisma.ingestionJob.create({\r\n    data: {\r\n      organizationId,\r\n      platform: platformCode,\r\n      jobType: \"COST_SYNC\",\r\n      status: \"QUEUED\",\r\n      idempotencyKey,\r\n      payload: {\r\n        fromDate: fromDate.toISOString(),\r\n        toDate: toDate.toISOString(),\r\n        grains,\r\n      },\r\n    },\r\n  });\r\n\r\n  return { id: job.id };\r\n}\r\n\r\n/**\r\n * Update ingestion job status\r\n */\r\nasync function updateIngestionJob(\r\n  jobId: string,\r\n  status: IngestionJobStatus,\r\n  result?: any,\r\n  error?: string\r\n): Promise<void> {\r\n  await prisma.ingestionJob.update({\r\n    where: { id: jobId },\r\n    data: {\r\n      status,\r\n      ...(result ? { payload: result } : {}),\r\n      ...(error ? { lastError: error } : {}),\r\n      attempts: { increment: 1 },\r\n      updatedAt: new Date(),\r\n    },\r\n  });\r\n}\r\n","/**\r\n * Token Refresh Utilities\r\n * \r\n * Handles automatic token refresh for OAuth integrations\r\n */\r\n\r\nimport \"server-only\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { encryptToken, decryptToken } from \"./encryption\";\r\nimport { appLogger } from \"@/lib/observability\";\r\n\r\n/**\r\n * Refresh Google Ads access token using refresh token\r\n */\r\nexport async function refreshGoogleAdsToken(connectionId: string): Promise<{\r\n  accessToken: string;\r\n  expiresAt: Date;\r\n}> {\r\n  const logger = appLogger.child({ integration: \"google-ads-refresh\" });\r\n\r\n  // Get connection\r\n  const connection = await prisma.integrationConnection.findUnique({\r\n    where: { id: connectionId },\r\n  });\r\n\r\n  if (!connection || connection.platformCode !== \"GOOGLE_ADS\") {\r\n    throw new Error(\"Invalid Google Ads connection\");\r\n  }\r\n\r\n  if (!connection.refreshTokenEnc) {\r\n    throw new Error(\"No refresh token available\");\r\n  }\r\n\r\n  // Decrypt refresh token\r\n  const refreshToken = decryptToken(connection.refreshTokenEnc);\r\n\r\n  // Request new access token\r\n  const response = await fetch(\"https://oauth2.googleapis.com/token\", {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n    body: new URLSearchParams({\r\n      client_id: process.env.GOOGLE_CLIENT_ID!,\r\n      client_secret: process.env.GOOGLE_CLIENT_SECRET!,\r\n      refresh_token: refreshToken,\r\n      grant_type: \"refresh_token\",\r\n    }),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const error = await response.text();\r\n    logger.error(\"Failed to refresh Google Ads token\", { error });\r\n    \r\n    // Mark connection as error\r\n    await prisma.integrationConnection.update({\r\n      where: { id: connectionId },\r\n      data: { status: \"ERROR\" },\r\n    });\r\n\r\n    throw new Error(\"Failed to refresh token\");\r\n  }\r\n\r\n  const data = await response.json();\r\n  const accessToken = data.access_token;\r\n  const expiresIn = data.expires_in || 3600;\r\n  const expiresAt = new Date(Date.now() + expiresIn * 1000);\r\n\r\n  // Encrypt and store new access token\r\n  const accessTokenEnc = encryptToken(accessToken);\r\n\r\n  await prisma.integrationConnection.update({\r\n    where: { id: connectionId },\r\n    data: {\r\n      accessTokenEnc,\r\n      accessTokenExpiresAt: expiresAt,\r\n      status: \"CONNECTED\",\r\n      updatedAt: new Date(),\r\n    },\r\n  });\r\n\r\n  logger.info(\"Refreshed Google Ads token\", { connectionId });\r\n\r\n  return { accessToken, expiresAt };\r\n}\r\n\r\n/**\r\n * Refresh Meta access token (exchange for long-lived token)\r\n */\r\nexport async function refreshMetaToken(connectionId: string): Promise<{\r\n  accessToken: string;\r\n  expiresAt: Date;\r\n}> {\r\n  const logger = appLogger.child({ integration: \"meta-refresh\" });\r\n\r\n  // Get connection\r\n  const connection = await prisma.integrationConnection.findUnique({\r\n    where: { id: connectionId },\r\n  });\r\n\r\n  if (!connection || connection.platformCode !== \"META_ADS\") {\r\n    throw new Error(\"Invalid Meta connection\");\r\n  }\r\n\r\n  if (!connection.accessTokenEnc) {\r\n    throw new Error(\"No access token available\");\r\n  }\r\n\r\n  // Decrypt current token\r\n  const currentToken = decryptToken(connection.accessTokenEnc);\r\n\r\n  // Exchange for new long-lived token\r\n  const response = await fetch(\r\n    `https://graph.facebook.com/v18.0/oauth/access_token?` +\r\n    `grant_type=fb_exchange_token&` +\r\n    `client_id=${process.env.META_APP_ID}&` +\r\n    `client_secret=${process.env.META_APP_SECRET}&` +\r\n    `fb_exchange_token=${currentToken}`\r\n  );\r\n\r\n  if (!response.ok) {\r\n    const error = await response.text();\r\n    logger.error(\"Failed to refresh Meta token\", { error });\r\n    \r\n    // Mark connection as error\r\n    await prisma.integrationConnection.update({\r\n      where: { id: connectionId },\r\n      data: { status: \"ERROR\" },\r\n    });\r\n\r\n    throw new Error(\"Failed to refresh token\");\r\n  }\r\n\r\n  const data = await response.json();\r\n  const accessToken = data.access_token;\r\n  const expiresIn = data.expires_in || 5184000; // 60 days\r\n  const expiresAt = new Date(Date.now() + expiresIn * 1000);\r\n\r\n  // Encrypt and store new access token\r\n  const accessTokenEnc = encryptToken(accessToken);\r\n\r\n  await prisma.integrationConnection.update({\r\n    where: { id: connectionId },\r\n    data: {\r\n      accessTokenEnc,\r\n      accessTokenExpiresAt: expiresAt,\r\n      status: \"CONNECTED\",\r\n      updatedAt: new Date(),\r\n    },\r\n  });\r\n\r\n  logger.info(\"Refreshed Meta token\", { connectionId });\r\n\r\n  return { accessToken, expiresAt };\r\n}\r\n\r\n/**\r\n * Get valid access token for a connection (auto-refresh if needed)\r\n */\r\nexport async function getValidAccessToken(connectionId: string): Promise<string> {\r\n  const connection = await prisma.integrationConnection.findUnique({\r\n    where: { id: connectionId },\r\n  });\r\n\r\n  if (!connection) {\r\n    throw new Error(\"Connection not found\");\r\n  }\r\n\r\n  if (connection.status !== \"CONNECTED\") {\r\n    throw new Error(\"Connection is not active\");\r\n  }\r\n\r\n  if (!connection.accessTokenEnc) {\r\n    throw new Error(\"No access token available\");\r\n  }\r\n\r\n  // Check if token is expired or will expire soon (within 5 minutes)\r\n  const now = new Date();\r\n  const expiresAt = connection.accessTokenExpiresAt;\r\n  const needsRefresh = !expiresAt || expiresAt.getTime() - now.getTime() < 5 * 60 * 1000;\r\n\r\n  if (needsRefresh) {\r\n    // Refresh token based on platform\r\n    if (connection.platformCode === \"GOOGLE_ADS\") {\r\n      const { accessToken } = await refreshGoogleAdsToken(connectionId);\r\n      return accessToken;\r\n    } else if (connection.platformCode === \"META_ADS\") {\r\n      const { accessToken } = await refreshMetaToken(connectionId);\r\n      return accessToken;\r\n    }\r\n  }\r\n\r\n  // Token is still valid, decrypt and return\r\n  return decryptToken(connection.accessTokenEnc);\r\n}\r\n\r\n/**\r\n * Refresh all expiring tokens (cron job)\r\n */\r\nexport async function refreshExpiringTokens(): Promise<{\r\n  refreshed: number;\r\n  failed: number;\r\n}> {\r\n  const logger = appLogger.child({ job: \"token-refresh\" });\r\n\r\n  // Find connections with tokens expiring in the next 24 hours\r\n  const expiringConnections = await prisma.integrationConnection.findMany({\r\n    where: {\r\n      status: \"CONNECTED\",\r\n      accessTokenExpiresAt: {\r\n        lte: new Date(Date.now() + 24 * 60 * 60 * 1000),\r\n      },\r\n    },\r\n  });\r\n\r\n  let refreshed = 0;\r\n  let failed = 0;\r\n\r\n  for (const connection of expiringConnections) {\r\n    try {\r\n      if (connection.platformCode === \"GOOGLE_ADS\") {\r\n        await refreshGoogleAdsToken(connection.id);\r\n        refreshed++;\r\n      } else if (connection.platformCode === \"META_ADS\") {\r\n        await refreshMetaToken(connection.id);\r\n        refreshed++;\r\n      }\r\n    } catch (error) {\r\n      logger.error(\"Failed to refresh token\", {\r\n        connectionId: connection.id,\r\n        platform: connection.platformCode,\r\n        error,\r\n      });\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  logger.info(\"Token refresh completed\", { refreshed, failed });\r\n\r\n  return { refreshed, failed };\r\n}\r\n","/**\r\n * Meta Ads API Client\r\n * \r\n * Fetches cost data from Meta (Facebook) Ads API with rate limiting\r\n */\r\n\r\nimport \"server-only\";\r\nimport { appLogger } from \"@/lib/observability\";\r\n\r\nconst API_VERSION = \"v18.0\";\r\nconst BASE_URL = `https://graph.facebook.com/${API_VERSION}`;\r\n\r\n// Rate limiting: 200 calls per hour per user\r\nconst RATE_LIMIT_DELAY_MS = 200; // ~18 seconds between calls to stay under limit\r\n\r\nexport interface MetaCostData {\r\n  date: string;\r\n  grain: \"CAMPAIGN\" | \"ADSET\" | \"AD\";\r\n  entityExternalId: string;\r\n  entityName: string;\r\n  campaignExternalId?: string;\r\n  campaignName?: string;\r\n  adsetExternalId?: string;\r\n  adsetName?: string;\r\n  adExternalId?: string;\r\n  adName?: string;\r\n  impressions: number;\r\n  clicks: number;\r\n  spendMicros: number;\r\n}\r\n\r\ninterface MetaInsightsResponse {\r\n  data: Array<{\r\n    date_start: string;\r\n    date_stop: string;\r\n    campaign_id?: string;\r\n    campaign_name?: string;\r\n    adset_id?: string;\r\n    adset_name?: string;\r\n    ad_id?: string;\r\n    ad_name?: string;\r\n    impressions: string;\r\n    clicks: string;\r\n    spend: string;\r\n  }>;\r\n  paging?: {\r\n    cursors?: {\r\n      before: string;\r\n      after: string;\r\n    };\r\n    next?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Fetch daily cost data from Meta Ads API\r\n */\r\nexport async function fetchMetaCostData(\r\n  accessToken: string,\r\n  adAccountId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  grain: \"CAMPAIGN\" | \"ADSET\" | \"AD\" = \"CAMPAIGN\"\r\n): Promise<MetaCostData[]> {\r\n  const logger = appLogger.child({ integration: \"meta-ads-client\" });\r\n\r\n  const dateStart = startDate.toISOString().split(\"T\")[0];\r\n  const dateStop = endDate.toISOString().split(\"T\")[0];\r\n\r\n  // Determine level and fields based on grain\r\n  let level: string;\r\n  let breakdowns: string[] = [];\r\n  \r\n  switch (grain) {\r\n    case \"CAMPAIGN\":\r\n      level = \"campaign\";\r\n      break;\r\n    case \"ADSET\":\r\n      level = \"adset\";\r\n      break;\r\n    case \"AD\":\r\n      level = \"ad\";\r\n      break;\r\n  }\r\n\r\n  const fields = [\r\n    \"campaign_id\",\r\n    \"campaign_name\",\r\n    \"adset_id\",\r\n    \"adset_name\",\r\n    \"ad_id\",\r\n    \"ad_name\",\r\n    \"impressions\",\r\n    \"clicks\",\r\n    \"spend\",\r\n  ].join(\",\");\r\n\r\n  const url = new URL(`${BASE_URL}/${adAccountId}/insights`);\r\n  url.searchParams.set(\"access_token\", accessToken);\r\n  url.searchParams.set(\"level\", level);\r\n  url.searchParams.set(\"fields\", fields);\r\n  url.searchParams.set(\"time_range\", JSON.stringify({\r\n    since: dateStart,\r\n    until: dateStop,\r\n  }));\r\n  url.searchParams.set(\"time_increment\", \"1\"); // Daily breakdown\r\n  url.searchParams.set(\"limit\", \"1000\");\r\n\r\n  const allData: MetaCostData[] = [];\r\n  let nextUrl: string | undefined = url.toString();\r\n\r\n  while (nextUrl) {\r\n    logger.debug(\"Fetching Meta insights\", { adAccountId, level, url: nextUrl });\r\n\r\n    const response = await fetch(nextUrl);\r\n\r\n    if (!response.ok) {\r\n      const error = await response.text();\r\n      logger.error(\"Meta API error\", { status: response.status, error });\r\n      \r\n      // Handle rate limiting\r\n      if (response.status === 429) {\r\n        const retryAfter = response.headers.get(\"retry-after\");\r\n        const delayMs = retryAfter ? parseInt(retryAfter) * 1000 : 60000;\r\n        logger.warn(\"Rate limited, waiting\", { delayMs });\r\n        await sleep(delayMs);\r\n        continue; // Retry same request\r\n      }\r\n\r\n      throw new Error(`Meta API error: ${response.status} ${error}`);\r\n    }\r\n\r\n    const data: MetaInsightsResponse = await response.json();\r\n\r\n    // Transform to our format\r\n    for (const insight of data.data) {\r\n      const costData: MetaCostData = {\r\n        date: insight.date_start,\r\n        grain,\r\n        entityExternalId: \"\",\r\n        entityName: \"\",\r\n        impressions: parseInt(insight.impressions || \"0\"),\r\n        clicks: parseInt(insight.clicks || \"0\"),\r\n        spendMicros: Math.round(parseFloat(insight.spend || \"0\") * 1_000_000),\r\n      };\r\n\r\n      // Set entity ID and name based on grain\r\n      switch (grain) {\r\n        case \"CAMPAIGN\":\r\n          costData.entityExternalId = insight.campaign_id || \"\";\r\n          costData.entityName = insight.campaign_name || \"\";\r\n          costData.campaignExternalId = insight.campaign_id;\r\n          costData.campaignName = insight.campaign_name;\r\n          break;\r\n        case \"ADSET\":\r\n          costData.entityExternalId = insight.adset_id || \"\";\r\n          costData.entityName = insight.adset_name || \"\";\r\n          costData.campaignExternalId = insight.campaign_id;\r\n          costData.campaignName = insight.campaign_name;\r\n          costData.adsetExternalId = insight.adset_id;\r\n          costData.adsetName = insight.adset_name;\r\n          break;\r\n        case \"AD\":\r\n          costData.entityExternalId = insight.ad_id || \"\";\r\n          costData.entityName = insight.ad_name || \"\";\r\n          costData.campaignExternalId = insight.campaign_id;\r\n          costData.campaignName = insight.campaign_name;\r\n          costData.adsetExternalId = insight.adset_id;\r\n          costData.adsetName = insight.adset_name;\r\n          costData.adExternalId = insight.ad_id;\r\n          costData.adName = insight.ad_name;\r\n          break;\r\n      }\r\n\r\n      allData.push(costData);\r\n    }\r\n\r\n    // Check for pagination\r\n    nextUrl = data.paging?.next;\r\n\r\n    // Rate limiting delay\r\n    if (nextUrl) {\r\n      await sleep(RATE_LIMIT_DELAY_MS);\r\n    }\r\n  }\r\n\r\n  logger.info(\"Fetched Meta cost data\", {\r\n    adAccountId,\r\n    grain,\r\n    records: allData.length,\r\n  });\r\n\r\n  return allData;\r\n}\r\n\r\n/**\r\n * Sleep utility\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Retry wrapper with exponential backoff\r\n */\r\nexport async function withRetry<T>(\r\n  fn: () => Promise<T>,\r\n  maxRetries: number = 3,\r\n  baseDelayMs: number = 1000\r\n): Promise<T> {\r\n  let lastError: Error | undefined;\r\n\r\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      lastError = error as Error;\r\n      \r\n      if (attempt < maxRetries - 1) {\r\n        const delayMs = baseDelayMs * Math.pow(2, attempt);\r\n        await sleep(delayMs);\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError;\r\n}\r\n","/**\r\n * Google Ads API Client\r\n * \r\n * Fetches cost data from Google Ads API with rate limiting\r\n */\r\n\r\nimport \"server-only\";\r\nimport { appLogger } from \"@/lib/observability\";\r\n\r\nconst API_VERSION = \"v16\";\r\nconst BASE_URL = `https://googleads.googleapis.com/${API_VERSION}`;\r\n\r\n// Rate limiting: 15,000 operations per day per developer token\r\n// Conservative: ~6 requests per minute\r\nconst RATE_LIMIT_DELAY_MS = 10000; // 10 seconds between calls\r\n\r\nexport interface GoogleAdsCostData {\r\n  date: string;\r\n  grain: \"CAMPAIGN\" | \"ADSET\" | \"AD\";\r\n  entityExternalId: string;\r\n  entityName: string;\r\n  campaignExternalId?: string;\r\n  campaignName?: string;\r\n  adGroupExternalId?: string;\r\n  adGroupName?: string;\r\n  adExternalId?: string;\r\n  adName?: string;\r\n  impressions: number;\r\n  clicks: number;\r\n  spendMicros: number;\r\n}\r\n\r\ninterface GoogleAdsReportRow {\r\n  segments?: {\r\n    date?: string;\r\n  };\r\n  campaign?: {\r\n    id?: string;\r\n    name?: string;\r\n  };\r\n  adGroup?: {\r\n    id?: string;\r\n    name?: string;\r\n  };\r\n  adGroupAd?: {\r\n    ad?: {\r\n      id?: string;\r\n      name?: string;\r\n    };\r\n  };\r\n  metrics?: {\r\n    impressions?: string;\r\n    clicks?: string;\r\n    costMicros?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Fetch daily cost data from Google Ads API\r\n */\r\nexport async function fetchGoogleAdsCostData(\r\n  accessToken: string,\r\n  developerToken: string,\r\n  customerId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  grain: \"CAMPAIGN\" | \"ADSET\" | \"AD\" = \"CAMPAIGN\"\r\n): Promise<GoogleAdsCostData[]> {\r\n  const logger = appLogger.child({ integration: \"google-ads-client\" });\r\n\r\n  const dateStart = startDate.toISOString().split(\"T\")[0].replace(/-/g, \"\");\r\n  const dateStop = endDate.toISOString().split(\"T\")[0].replace(/-/g, \"\");\r\n\r\n  // Build GAQL query based on grain\r\n  let query: string;\r\n  \r\n  switch (grain) {\r\n    case \"CAMPAIGN\":\r\n      query = `\r\n        SELECT\r\n          segments.date,\r\n          campaign.id,\r\n          campaign.name,\r\n          metrics.impressions,\r\n          metrics.clicks,\r\n          metrics.cost_micros\r\n        FROM campaign\r\n        WHERE segments.date BETWEEN '${dateStart}' AND '${dateStop}'\r\n          AND campaign.status != 'REMOVED'\r\n      `;\r\n      break;\r\n    case \"ADSET\":\r\n      query = `\r\n        SELECT\r\n          segments.date,\r\n          campaign.id,\r\n          campaign.name,\r\n          ad_group.id,\r\n          ad_group.name,\r\n          metrics.impressions,\r\n          metrics.clicks,\r\n          metrics.cost_micros\r\n        FROM ad_group\r\n        WHERE segments.date BETWEEN '${dateStart}' AND '${dateStop}'\r\n          AND ad_group.status != 'REMOVED'\r\n      `;\r\n      break;\r\n    case \"AD\":\r\n      query = `\r\n        SELECT\r\n          segments.date,\r\n          campaign.id,\r\n          campaign.name,\r\n          ad_group.id,\r\n          ad_group.name,\r\n          ad_group_ad.ad.id,\r\n          ad_group_ad.ad.name,\r\n          metrics.impressions,\r\n          metrics.clicks,\r\n          metrics.cost_micros\r\n        FROM ad_group_ad\r\n        WHERE segments.date BETWEEN '${dateStart}' AND '${dateStop}'\r\n          AND ad_group_ad.status != 'REMOVED'\r\n      `;\r\n      break;\r\n  }\r\n\r\n  const url = `${BASE_URL}/customers/${customerId}/googleAds:search`;\r\n  \r\n  const allData: GoogleAdsCostData[] = [];\r\n  let pageToken: string | undefined;\r\n\r\n  do {\r\n    logger.debug(\"Fetching Google Ads report\", { customerId, grain });\r\n\r\n    const requestBody: any = { query };\r\n    if (pageToken) {\r\n      requestBody.pageToken = pageToken;\r\n    }\r\n\r\n    const response = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Authorization\": `Bearer ${accessToken}`,\r\n        \"developer-token\": developerToken,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify(requestBody),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const error = await response.text();\r\n      logger.error(\"Google Ads API error\", { status: response.status, error });\r\n      \r\n      // Handle rate limiting\r\n      if (response.status === 429) {\r\n        const retryAfter = response.headers.get(\"retry-after\");\r\n        const delayMs = retryAfter ? parseInt(retryAfter) * 1000 : 60000;\r\n        logger.warn(\"Rate limited, waiting\", { delayMs });\r\n        await sleep(delayMs);\r\n        continue; // Retry same request\r\n      }\r\n\r\n      throw new Error(`Google Ads API error: ${response.status} ${error}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const results: GoogleAdsReportRow[] = data.results || [];\r\n\r\n    // Transform to our format\r\n    for (const row of results) {\r\n      const costData: GoogleAdsCostData = {\r\n        date: row.segments?.date || \"\",\r\n        grain,\r\n        entityExternalId: \"\",\r\n        entityName: \"\",\r\n        impressions: parseInt(row.metrics?.impressions || \"0\"),\r\n        clicks: parseInt(row.metrics?.clicks || \"0\"),\r\n        spendMicros: parseInt(row.metrics?.costMicros || \"0\"),\r\n      };\r\n\r\n      // Set entity ID and name based on grain\r\n      switch (grain) {\r\n        case \"CAMPAIGN\":\r\n          costData.entityExternalId = row.campaign?.id?.toString() || \"\";\r\n          costData.entityName = row.campaign?.name || \"\";\r\n          costData.campaignExternalId = row.campaign?.id?.toString();\r\n          costData.campaignName = row.campaign?.name;\r\n          break;\r\n        case \"ADSET\":\r\n          costData.entityExternalId = row.adGroup?.id?.toString() || \"\";\r\n          costData.entityName = row.adGroup?.name || \"\";\r\n          costData.campaignExternalId = row.campaign?.id?.toString();\r\n          costData.campaignName = row.campaign?.name;\r\n          costData.adGroupExternalId = row.adGroup?.id?.toString();\r\n          costData.adGroupName = row.adGroup?.name;\r\n          break;\r\n        case \"AD\":\r\n          costData.entityExternalId = row.adGroupAd?.ad?.id?.toString() || \"\";\r\n          costData.entityName = row.adGroupAd?.ad?.name || \"\";\r\n          costData.campaignExternalId = row.campaign?.id?.toString();\r\n          costData.campaignName = row.campaign?.name;\r\n          costData.adGroupExternalId = row.adGroup?.id?.toString();\r\n          costData.adGroupName = row.adGroup?.name;\r\n          costData.adExternalId = row.adGroupAd?.ad?.id?.toString();\r\n          costData.adName = row.adGroupAd?.ad?.name;\r\n          break;\r\n      }\r\n\r\n      allData.push(costData);\r\n    }\r\n\r\n    // Check for pagination\r\n    pageToken = data.nextPageToken;\r\n\r\n    // Rate limiting delay\r\n    if (pageToken) {\r\n      await sleep(RATE_LIMIT_DELAY_MS);\r\n    }\r\n  } while (pageToken);\r\n\r\n  logger.info(\"Fetched Google Ads cost data\", {\r\n    customerId,\r\n    grain,\r\n    records: allData.length,\r\n  });\r\n\r\n  return allData;\r\n}\r\n\r\n/**\r\n * Sleep utility\r\n */\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Retry wrapper with exponential backoff\r\n */\r\nexport async function withRetry<T>(\r\n  fn: () => Promise<T>,\r\n  maxRetries: number = 3,\r\n  baseDelayMs: number = 1000\r\n): Promise<T> {\r\n  let lastError: Error | undefined;\r\n\r\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      lastError = error as Error;\r\n      \r\n      if (attempt < maxRetries - 1) {\r\n        const delayMs = baseDelayMs * Math.pow(2, attempt);\r\n        await sleep(delayMs);\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError;\r\n}\r\n"],"names":[],"mappings":"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"}