{"version":3,"sources":["../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/jobs/touchpoint-derivation.ts","../../../../../../../../../../OneDrive/Desktop/Optiq/CascadeProjects/windsurf-project/apps/frontend/src/lib/attribution/types.ts"],"sourcesContent":["/**\r\n * TouchPoint Derivation Job\r\n * \r\n * Derives TouchPoint records from TrackingEvent PAGE_VIEW events.\r\n * \r\n * Canonical Rule:\r\n * - TrackingEvent = raw inbound events (all types: PAGE_VIEW, CONVERSION, CUSTOM)\r\n * - TouchPoint = derived marketing touchpoints (one per session landing or click ID)\r\n * \r\n * Derivation Logic:\r\n * - Creates TouchPoint from PAGE_VIEW events that represent session landings\r\n * - Idempotent: unique by siteId+sessionId+landingUrl OR clickId\r\n * - Captures UTM parameters, click IDs, referrer, and inferred platform/campaign\r\n * \r\n * Features:\r\n * - Processes unprocessed PAGE_VIEW events\r\n * - Deduplicates based on unique constraints\r\n * - Infers platform from click IDs (gclid → GOOGLE_ADS, fbclid → META, etc.)\r\n * - Links to campaigns via UTM parameters or click IDs\r\n * - Idempotent and rebuildable\r\n */\r\n\r\nimport \"server-only\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { appLogger } from \"@/lib/observability\";\r\nimport { extractClickIds, inferPlatformFromClickId } from \"@/lib/attribution/types\";\r\n\r\nexport interface TouchPointDerivationResult {\r\n  startedAt: Date;\r\n  completedAt: Date;\r\n  eventsProcessed: number;\r\n  touchPointsCreated: number;\r\n  touchPointsSkipped: number;\r\n  errors: number;\r\n}\r\n\r\nexport interface TouchPointDerivationOptions {\r\n  /** Specific site to process */\r\n  siteId?: string;\r\n  /** Start date for events to process */\r\n  startDate?: Date;\r\n  /** End date for events to process */\r\n  endDate?: Date;\r\n  /** Batch size for processing */\r\n  batchSize?: number;\r\n  /** Force reprocessing of all events */\r\n  force?: boolean;\r\n}\r\n\r\nconst DEFAULT_BATCH_SIZE = 1000;\r\nconst DEFAULT_LOOKBACK_DAYS = 7;\r\n\r\n/**\r\n * Run the TouchPoint derivation job\r\n */\r\nexport async function runTouchPointDerivation(\r\n  options?: TouchPointDerivationOptions\r\n): Promise<TouchPointDerivationResult> {\r\n  const logger = appLogger.child({ job: \"touchpoint-derivation\" });\r\n  const startedAt = new Date();\r\n\r\n  const batchSize = options?.batchSize ?? DEFAULT_BATCH_SIZE;\r\n  const endDate = options?.endDate ?? new Date();\r\n  const startDate = options?.startDate ?? new Date(endDate.getTime() - DEFAULT_LOOKBACK_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  logger.info(\"Starting TouchPoint derivation\", {\r\n    siteId: options?.siteId,\r\n    startDate: startDate.toISOString(),\r\n    endDate: endDate.toISOString(),\r\n    batchSize,\r\n  });\r\n\r\n  let eventsProcessed = 0;\r\n  let touchPointsCreated = 0;\r\n  let touchPointsSkipped = 0;\r\n  let errors = 0;\r\n\r\n  try {\r\n    // Get sites to process\r\n    const sites = await getSitesToProcess(options?.siteId);\r\n\r\n    for (const site of sites) {\r\n      logger.info(`Processing site: ${site.id}`, { siteName: site.name });\r\n\r\n      let hasMore = true;\r\n      let lastProcessedAt: Date | null = null;\r\n\r\n      while (hasMore) {\r\n        // Get batch of PAGE_VIEW events\r\n        const events = await getPageViewEvents(\r\n          site.id,\r\n          startDate,\r\n          endDate,\r\n          batchSize,\r\n          lastProcessedAt\r\n        );\r\n\r\n        if (events.length === 0) {\r\n          hasMore = false;\r\n          break;\r\n        }\r\n\r\n        logger.debug(`Processing ${events.length} events for site ${site.id}`);\r\n\r\n        // Process each event\r\n        for (const event of events) {\r\n          try {\r\n            const result = await deriveTouchPoint(event);\r\n            eventsProcessed++;\r\n\r\n            if (result.created) {\r\n              touchPointsCreated++;\r\n            } else {\r\n              touchPointsSkipped++;\r\n            }\r\n\r\n            lastProcessedAt = event.occurredAt;\r\n          } catch (error) {\r\n            errors++;\r\n            logger.error(`Failed to derive TouchPoint from event ${event.id}`, error as Error, {\r\n              siteId: site.id,\r\n              eventId: event.id,\r\n            });\r\n          }\r\n        }\r\n\r\n        // If we got fewer events than batch size, we're done\r\n        if (events.length < batchSize) {\r\n          hasMore = false;\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.error(\"TouchPoint derivation job failed\", error as Error);\r\n    throw error;\r\n  }\r\n\r\n  const completedAt = new Date();\r\n\r\n  logger.info(\"TouchPoint derivation completed\", {\r\n    eventsProcessed,\r\n    touchPointsCreated,\r\n    touchPointsSkipped,\r\n    errors,\r\n    durationMs: completedAt.getTime() - startedAt.getTime(),\r\n  });\r\n\r\n  return {\r\n    startedAt,\r\n    completedAt,\r\n    eventsProcessed,\r\n    touchPointsCreated,\r\n    touchPointsSkipped,\r\n    errors,\r\n  };\r\n}\r\n\r\n/**\r\n * Get sites to process\r\n */\r\nasync function getSitesToProcess(siteId?: string): Promise<Array<{ id: string; name: string }>> {\r\n  if (siteId) {\r\n    const site = await prisma.trackingSite.findUnique({\r\n      where: { id: siteId },\r\n      select: { id: true, name: true },\r\n    });\r\n    return site ? [site] : [];\r\n  }\r\n\r\n  return prisma.trackingSite.findMany({\r\n    select: { id: true, name: true },\r\n  });\r\n}\r\n\r\n/**\r\n * Get PAGE_VIEW events to process\r\n */\r\nasync function getPageViewEvents(\r\n  siteId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  limit: number,\r\n  lastProcessedAt: Date | null\r\n): Promise<Array<{\r\n  id: string;\r\n  siteId: string;\r\n  anonId: string;\r\n  sessionId: string;\r\n  occurredAt: Date;\r\n  url: string;\r\n  referrer: string | null;\r\n  utmSource: string | null;\r\n  utmMedium: string | null;\r\n  utmCampaign: string | null;\r\n  utmTerm: string | null;\r\n  utmContent: string | null;\r\n}>> {\r\n  return prisma.trackingEvent.findMany({\r\n    where: {\r\n      siteId,\r\n      type: \"PAGE_VIEW\",\r\n      occurredAt: {\r\n        gte: lastProcessedAt ?? startDate,\r\n        lte: endDate,\r\n      },\r\n    },\r\n    select: {\r\n      id: true,\r\n      siteId: true,\r\n      anonId: true,\r\n      sessionId: true,\r\n      occurredAt: true,\r\n      url: true,\r\n      referrer: true,\r\n      utmSource: true,\r\n      utmMedium: true,\r\n      utmCampaign: true,\r\n      utmTerm: true,\r\n      utmContent: true,\r\n    },\r\n    orderBy: { occurredAt: \"asc\" },\r\n    take: limit,\r\n  });\r\n}\r\n\r\n/**\r\n * Derive TouchPoint from TrackingEvent\r\n */\r\nasync function deriveTouchPoint(event: {\r\n  id: string;\r\n  siteId: string;\r\n  anonId: string;\r\n  sessionId: string;\r\n  occurredAt: Date;\r\n  url: string;\r\n  referrer: string | null;\r\n  utmSource: string | null;\r\n  utmMedium: string | null;\r\n  utmCampaign: string | null;\r\n  utmTerm: string | null;\r\n  utmContent: string | null;\r\n}): Promise<{ created: boolean }> {\r\n  // Extract click IDs from URL\r\n  const clickIds = extractClickIds(event.url);\r\n  const hasClickId = !!(clickIds.gclid || clickIds.fbclid || clickIds.ttclid || clickIds.msclkid || clickIds.clickId);\r\n\r\n  // Infer platform from click IDs\r\n  const platformCode = inferPlatformFromClickId(clickIds);\r\n\r\n  // Determine if this is a session landing (first page view with UTMs or click IDs)\r\n  const isSessionLanding = !!(\r\n    event.utmSource ||\r\n    event.utmMedium ||\r\n    event.utmCampaign ||\r\n    hasClickId\r\n  );\r\n\r\n  // Only create TouchPoint for session landings\r\n  if (!isSessionLanding) {\r\n    return { created: false };\r\n  }\r\n\r\n  // Try to find matching campaign\r\n  let campaignId: string | null = null;\r\n  if (platformCode && event.utmCampaign) {\r\n    const campaign = await prisma.campaign.findFirst({\r\n      where: {\r\n        platform: { code: platformCode as any },\r\n        name: { contains: event.utmCampaign, mode: \"insensitive\" },\r\n      },\r\n      select: { id: true },\r\n    });\r\n    campaignId = campaign?.id ?? null;\r\n  }\r\n\r\n  // Create TouchPoint (idempotent via unique constraints)\r\n  try {\r\n    await prisma.touchPoint.create({\r\n      data: {\r\n        siteId: event.siteId,\r\n        anonId: event.anonId,\r\n        sessionId: event.sessionId,\r\n        occurredAt: event.occurredAt,\r\n        landingUrl: event.url,\r\n        referrer: event.referrer,\r\n        utmSource: event.utmSource,\r\n        utmMedium: event.utmMedium,\r\n        utmCampaign: event.utmCampaign,\r\n        utmTerm: event.utmTerm,\r\n        utmContent: event.utmContent,\r\n        gclid: clickIds.gclid,\r\n        fbclid: clickIds.fbclid,\r\n        ttclid: clickIds.ttclid,\r\n        msclkid: clickIds.msclkid,\r\n        clickId: clickIds.clickId,\r\n        platformCode,\r\n        campaignId,\r\n      },\r\n    });\r\n\r\n    return { created: true };\r\n  } catch (error: any) {\r\n    // Check if it's a unique constraint violation (already exists)\r\n    if (error.code === \"P2002\") {\r\n      return { created: false }; // Already exists, skip\r\n    }\r\n    throw error; // Re-throw other errors\r\n  }\r\n}\r\n\r\n/**\r\n * Rebuild TouchPoints for a date range\r\n * Deletes existing TouchPoints and recreates them\r\n */\r\nexport async function rebuildTouchPoints(options: {\r\n  siteId?: string;\r\n  startDate: Date;\r\n  endDate: Date;\r\n}): Promise<TouchPointDerivationResult> {\r\n  const logger = appLogger.child({ job: \"touchpoint-rebuild\" });\r\n\r\n  logger.info(\"Rebuilding TouchPoints\", {\r\n    siteId: options.siteId,\r\n    startDate: options.startDate.toISOString(),\r\n    endDate: options.endDate.toISOString(),\r\n  });\r\n\r\n  // Delete existing TouchPoints in the date range\r\n  const deleteResult = await prisma.touchPoint.deleteMany({\r\n    where: {\r\n      ...(options.siteId ? { siteId: options.siteId } : {}),\r\n      occurredAt: {\r\n        gte: options.startDate,\r\n        lte: options.endDate,\r\n      },\r\n    },\r\n  });\r\n\r\n  logger.info(`Deleted ${deleteResult.count} existing TouchPoints`);\r\n\r\n  // Run derivation\r\n  return runTouchPointDerivation({\r\n    siteId: options.siteId,\r\n    startDate: options.startDate,\r\n    endDate: options.endDate,\r\n    force: true,\r\n  });\r\n}\r\n\r\n/**\r\n * Get TouchPoint derivation stats\r\n */\r\nexport async function getTouchPointStats(siteId?: string): Promise<{\r\n  totalEvents: number;\r\n  totalTouchPoints: number;\r\n  touchPointsWithClickIds: number;\r\n  touchPointsWithUTMs: number;\r\n  touchPointsLinkedToCampaigns: number;\r\n  platformBreakdown: Record<string, number>;\r\n}> {\r\n  const where = siteId ? { siteId } : {};\r\n\r\n  const [\r\n    totalEvents,\r\n    totalTouchPoints,\r\n    touchPointsWithClickIds,\r\n    touchPointsWithUTMs,\r\n    touchPointsLinkedToCampaigns,\r\n    platformGroups,\r\n  ] = await Promise.all([\r\n    prisma.trackingEvent.count({ where: { ...where, type: \"PAGE_VIEW\" } }),\r\n    prisma.touchPoint.count({ where }),\r\n    prisma.touchPoint.count({\r\n      where: {\r\n        ...where,\r\n        OR: [\r\n          { gclid: { not: null } },\r\n          { fbclid: { not: null } },\r\n          { ttclid: { not: null } },\r\n          { msclkid: { not: null } },\r\n          { clickId: { not: null } },\r\n        ],\r\n      },\r\n    }),\r\n    prisma.touchPoint.count({\r\n      where: {\r\n        ...where,\r\n        OR: [\r\n          { utmSource: { not: null } },\r\n          { utmMedium: { not: null } },\r\n          { utmCampaign: { not: null } },\r\n        ],\r\n      },\r\n    }),\r\n    prisma.touchPoint.count({\r\n      where: {\r\n        ...where,\r\n        campaignId: { not: null },\r\n      },\r\n    }),\r\n    prisma.touchPoint.groupBy({\r\n      by: [\"platformCode\"],\r\n      where,\r\n      _count: true,\r\n    }),\r\n  ]);\r\n\r\n  const platformBreakdown: Record<string, number> = {};\r\n  for (const group of platformGroups) {\r\n    if (group.platformCode) {\r\n      platformBreakdown[group.platformCode] = group._count;\r\n    }\r\n  }\r\n\r\n  return {\r\n    totalEvents,\r\n    totalTouchPoints,\r\n    touchPointsWithClickIds,\r\n    touchPointsWithUTMs,\r\n    touchPointsLinkedToCampaigns,\r\n    platformBreakdown,\r\n  };\r\n}\r\n","import \"server-only\";\r\nimport type { AttributionModel as PrismaAttributionModel } from \"@prisma/client\";\r\n\r\n// Re-export Prisma's AttributionModel enum\r\nexport type AttributionModel = PrismaAttributionModel;\r\n\r\nexport type TouchPointData = {\r\n  id: string;\r\n  siteId: string;\r\n  anonId: string;\r\n  sessionId: string;\r\n  occurredAt: Date;\r\n\r\n  utmSource: string | null;\r\n  utmMedium: string | null;\r\n  utmCampaign: string | null;\r\n  utmTerm: string | null;\r\n  utmContent: string | null;\r\n\r\n  gclid: string | null;\r\n  fbclid: string | null;\r\n  ttclid: string | null;\r\n  msclkid: string | null;\r\n  clickId: string | null;\r\n\r\n  referrer: string | null;\r\n  landingUrl: string | null;\r\n\r\n  platformCode: string | null;\r\n  campaignId: string | null;\r\n  adAccountId: string | null;\r\n  adId: string | null;\r\n};\r\n\r\nexport type ConversionData = {\r\n  id: string;\r\n  siteId: string;\r\n  anonId: string;\r\n  occurredAt: Date;\r\n};\r\n\r\nexport type AttributionLinkInput = {\r\n  siteId: string;\r\n  conversionId: string;\r\n  touchPointId: string;\r\n  model: AttributionModel;\r\n  weight: number;\r\n  position: number;\r\n  touchPointCount: number;\r\n};\r\n\r\nexport function extractClickIds(url: string): {\r\n  gclid: string | null;\r\n  fbclid: string | null;\r\n  ttclid: string | null;\r\n  msclkid: string | null;\r\n  clickId: string | null;\r\n} {\r\n  try {\r\n    const u = new URL(url);\r\n    return {\r\n      gclid: u.searchParams.get(\"gclid\"),\r\n      fbclid: u.searchParams.get(\"fbclid\"),\r\n      ttclid: u.searchParams.get(\"ttclid\"),\r\n      msclkid: u.searchParams.get(\"msclkid\"),\r\n      clickId:\r\n        u.searchParams.get(\"clickid\") ??\r\n        u.searchParams.get(\"click_id\") ??\r\n        null,\r\n    };\r\n  } catch {\r\n    return {\r\n      gclid: null,\r\n      fbclid: null,\r\n      ttclid: null,\r\n      msclkid: null,\r\n      clickId: null,\r\n    };\r\n  }\r\n}\r\n\r\nexport function inferPlatformFromClickId(clickIds: {\r\n  gclid: string | null;\r\n  fbclid: string | null;\r\n  ttclid: string | null;\r\n  msclkid: string | null;\r\n}): string | null {\r\n  if (clickIds.gclid) return \"GOOGLE_ADS\";\r\n  if (clickIds.fbclid) return \"META\";\r\n  if (clickIds.ttclid) return \"TIKTOK\";\r\n  if (clickIds.msclkid) return \"LINKEDIN\";\r\n  return null;\r\n}\r\n"],"names":[],"mappings":"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"}